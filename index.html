<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Интерактивные эффекты</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background: #f8f9fa;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        header {
            background: #ffffff;
            width: 100%;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        h1 {
            margin: 0;
            font-size: 24px;
        }

        .main-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 30px;
            max-width: 1200px;
            width: 100%;
        }

        .image-container {
            flex: 1;
            min-width: 300px;
            background: #fff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }

        .controls-container {
            flex: 1;
            min-width: 400px;
            background: #fff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
        }

        .file-input-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .btn-file-upload {}

        .file-name-display {
            font-size: 14px;
            color: #555;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: calc(100% - 150px);
        }

        canvas {
            display: block;
            max-width: 100%;
            max-height: 500px;
            width: auto;
            height: auto;
            margin-left: auto;
            margin-right: auto;
            border-radius: 8px;
            margin-bottom: 20px;
            background: #eee;
        }

        .controls {
            max-height: 350px;
            overflow-y: auto;
            padding-right: 10px;
            border: 1px solid #eee;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .controls label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
            font-size: 13px;
        }

        .controls input[type="range"],
        .controls select {
            width: 50%;
        }
        
        .controls input[type="color"] {
            width: 50%;
            height: 25px;
        }

        .controls input[type="checkbox"] {
            transform: scale(1.1);
        }

        .button-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-top: 10px;
        }

        .btn {
            background-color: #4f46e5;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            flex-grow: 1;
            text-align: center;
        }

        .btn-secondary {
            background-color: #6c757d;
        }

        .btn-secondary:hover {
            background-color: #5a6268;
        }

        .btn:hover {
            background-color: #3730a3;
        }

        .presets-container {
            margin-top: 20px;
            border: 1px solid #eee;
            padding: 15px;
            border-radius: 8px;
        }

        .presets-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .preset-btn {
            flex: 1;
        }
    </style>
</head>

<body>
    <header>
        <h1>Интерактивные эффекты для изображений</h1>
    </header>

    <div class="main-container">
        <div class="image-container">
            <div class="file-input-container">
                <input type="file" accept="image/*" id="imgLoader" class="visually-hidden">
                <label for="imgLoader" class="btn btn-file-upload">Выбрать файл</label>
                <span id="fileNameDisplay" class="file-name-display">Файл не выбран</span>
            </div>

            <canvas id="canvas"></canvas>
        </div>

        <div class="controls-container">
            <div class="controls">
                <label>Pixelation: <input type="range" id="pixelSlider" min="1" max="100" value="100"></label>
                <label>Posterize: <input type="range" id="posterizeSlider" min="1" max="50" value="50"></label>
                <label>CRT Lines: <input type="checkbox" id="crtCheckbox"></label>
                <label>Color Shift (Old): <input type="checkbox" id="shiftCheckbox"></label>
                <label>Noise: <input type="range" id="noiseSlider" min="0" max="100" value="0"></label>
                <label>Film Grain: <input type="range" id="filmGrainSlider" min="0" max="50" value="0"></label>
                <label>Row Shift: <input type="range" id="rowShiftSlider" min="0" max="30" value="0"></label>
                <label>Chromatic Aberration: <input type="range" id="chromaticAberrationSlider" min="0" max="10" value="0"></label>
                <label>Bad Pixels: <input type="range" id="badPixelsSlider" min="0" max="5" value="0"></label>
                <label>Simple Edges: <input type="range" id="edgeDetectionSlider" min="0" max="100" value="0"></label>
                
                <hr>

                <label>Palette:
                    <select id="paletteSelect">
                        <option value="none">None</option>
                        <option value="gameboy">Game Boy (4 Grays)</option>
                        <option value="nes8">NES-like (8 Colors)</option>
                        <option value="pico8">PICO-8 (16 Colors)</option>
                        <option value="websafe">Web Safe (216 Colors)</option>
                    </select>
                </label>
                <label>Dithering:
                    <select id="ditheringSelect">
                        <option value="none">None</option>
                        <option value="bayer2">Bayer 2x2</option>
                        <option value="bayer4">Bayer 4x4</option>
                    </select>
                </label>
                <label>Dither Strength: <input type="range" id="ditherStrengthSlider" min="0" max="100" value="20"></label>

                <label>Monochrome/Tint: <input type="checkbox" id="monoTintCheckbox"></label>
                <label>Tint Color:
                    <select id="tintColorSelect">
                        <option value="#9bbc0f">Game Boy Green</option>
                        <option value="#FF0000">Virtual Boy Red</option>
                        <option value="#FFB000">Amber</option>
                        <option value="#30FF30">Green CRT</option>
                        <option value="#808080">Grayscale</option>
                    </select>
                </label>

                <label>Screen Grid: <input type="checkbox" id="screenGridCheckbox"></label>
                <label>Grid Size: <input type="range" id="screenGridSizeSlider" min="1" max="10" value="3"></label>
                <label>Grid Opacity: <input type="range" id="screenGridOpacitySlider" min="0" max="100" value="30"></label>

                <label>Slight Blur: <input type="range" id="slightBlurSlider" min="0" max="5" value="0"></label>
                
                <label>NTSC Artifacts: <input type="checkbox" id="ntscArtifactsCheckbox"></label>
                <label>NTSC Intensity: <input type="range" id="ntscIntensitySlider" min="0" max="20" value="0"></label>

                <label>Barrel Distortion: <input type="range" id="barrelDistortionSlider" min="0" max="50" value="0"></label>
            </div>

            <div class="button-row">
                <button class="btn" onclick="updateCanvas()">Обновить</button>
                <button class="btn btn-secondary" onclick="resetSettings()">Сбросить</button>
                <button class="btn" onclick="saveImage()">Сохранить</button>
            </div>

            <div class="presets-container">
                <h3>Пресеты</h3>
                <div class="presets-row">
                    <button class="btn btn-secondary preset-btn" onclick="savePreset(1)">Сохранить 1</button>
                    <button class="btn btn-secondary preset-btn" onclick="loadPreset(1)">Загрузить 1</button>
                </div>
                <div class="presets-row">
                    <button class="btn btn-secondary preset-btn" onclick="savePreset(2)">Сохранить 2</button>
                    <button class="btn btn-secondary preset-btn" onclick="loadPreset(2)">Загрузить 2</button>
                </div>
                <div class="presets-row">
                    <button class="btn btn-secondary preset-btn" onclick="savePreset(3)">Сохранить 3</button>
                    <button class="btn btn-secondary preset-btn" onclick="loadPreset(3)">Загрузить 3</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const imgLoader = document.getElementById('imgLoader');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        let originalImage = null;

        // --- Ссылки на элементы управления ---
        const pixelSlider = document.getElementById('pixelSlider');
        const posterizeSlider = document.getElementById('posterizeSlider');
        const crtCheckbox = document.getElementById('crtCheckbox');
        const shiftCheckbox = document.getElementById('shiftCheckbox');
        const noiseSlider = document.getElementById('noiseSlider');
        const filmGrainSlider = document.getElementById('filmGrainSlider');
        const rowShiftSlider = document.getElementById('rowShiftSlider');
        const chromaticAberrationSlider = document.getElementById('chromaticAberrationSlider');
        const badPixelsSlider = document.getElementById('badPixelsSlider');
        const edgeDetectionSlider = document.getElementById('edgeDetectionSlider');
        const paletteSelect = document.getElementById('paletteSelect');
        const ditheringSelect = document.getElementById('ditheringSelect');
        const ditherStrengthSlider = document.getElementById('ditherStrengthSlider');
        const monoTintCheckbox = document.getElementById('monoTintCheckbox');
        const tintColorSelect = document.getElementById('tintColorSelect');
        const screenGridCheckbox = document.getElementById('screenGridCheckbox');
        const screenGridSizeSlider = document.getElementById('screenGridSizeSlider');
        const screenGridOpacitySlider = document.getElementById('screenGridOpacitySlider');
        const slightBlurSlider = document.getElementById('slightBlurSlider');
        const ntscArtifactsCheckbox = document.getElementById('ntscArtifactsCheckbox');
        const ntscIntensitySlider = document.getElementById('ntscIntensitySlider');
        const barrelDistortionSlider = document.getElementById('barrelDistortionSlider');

        // --- Начальные значения для сброса ---
        const defaultSettings = {
            pixelSlider: 100, posterizeSlider: 50, crtCheckbox: false, shiftCheckbox: false,
            noiseSlider: 0, filmGrainSlider: 0, rowShiftSlider: 0, chromaticAberrationSlider: 0,
            badPixelsSlider: 0, edgeDetectionSlider: 0,
            paletteSelect: 'none', ditheringSelect: 'none', ditherStrengthSlider: 20,
            monoTintCheckbox: false, tintColorSelect: '#9bbc0f',
            screenGridCheckbox: false, screenGridSizeSlider: 3, screenGridOpacitySlider: 30,
            slightBlurSlider: 0, ntscArtifactsCheckbox: false, ntscIntensitySlider: 0,
            barrelDistortionSlider: 0,
        };
        
        // --- Palettes ---
        const palettes = {
            gameboy: [[155, 188, 15], [139, 172, 15], [48, 98, 48], [15, 56, 15]],
            nes8: [[124,124,124],[0,0,252],[0,0,188],[68,40,188],[148,0,132],[188,0,0],[188,80,0],[160,120,0]],
            pico8: [[0,0,0],[29,43,83],[126,37,83],[0,135,81],[171,82,54],[95,87,79],[194,195,199],[255,241,232],[255,0,77],[255,163,0],[255,236,39],[0,228,54],[41,173,255],[131,118,156],[255,119,168],[255,204,170]],
            websafe: (() => {
                const p = []; const v = [0, 51, 102, 153, 204, 255];
                for (let r of v) for (let g of v) for (let b of v) p.push([r,g,b]);
                return p;
            })()
        };

        // --- Dithering Matrices ---
        const bayerMatrices = {
            bayer2: [[0, 2], [3, 1]],
            bayer4: [[0, 8, 2, 10], [12, 4, 14, 6], [3, 11, 1, 9], [15, 7, 13, 5]]
        };

        // --- Cookie Functions ---
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days*24*60*60*1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "")  + expires + "; path=/";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for(let i=0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0)==' ') c = c.substring(1,c.length);
                if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
            }
            return null;
        }

        function savePreset(presetNum) {
            const presetData = {
                pixelSlider: pixelSlider.value,
                posterizeSlider: posterizeSlider.value,
                crtCheckbox: crtCheckbox.checked,
                shiftCheckbox: shiftCheckbox.checked,
                noiseSlider: noiseSlider.value,
                filmGrainSlider: filmGrainSlider.value,
                rowShiftSlider: rowShiftSlider.value,
                chromaticAberrationSlider: chromaticAberrationSlider.value,
                badPixelsSlider: badPixelsSlider.value,
                edgeDetectionSlider: edgeDetectionSlider.value,
                paletteSelect: paletteSelect.value,
                ditheringSelect: ditheringSelect.value,
                ditherStrengthSlider: ditherStrengthSlider.value,
                monoTintCheckbox: monoTintCheckbox.checked,
                tintColorSelect: tintColorSelect.value,
                screenGridCheckbox: screenGridCheckbox.checked,
                screenGridSizeSlider: screenGridSizeSlider.value,
                screenGridOpacitySlider: screenGridOpacitySlider.value,
                slightBlurSlider: slightBlurSlider.value,
                ntscArtifactsCheckbox: ntscArtifactsCheckbox.checked,
                ntscIntensitySlider: ntscIntensitySlider.value,
                barrelDistortionSlider: barrelDistortionSlider.value
            };
            
            setCookie(`preset_${presetNum}`, JSON.stringify(presetData), 365);
            alert(`Пресет ${presetNum} сохранён!`);
        }

        function loadPreset(presetNum) {
            const presetData = getCookie(`preset_${presetNum}`);
            if (!presetData) {
                alert(`Пресет ${presetNum} не найден!`);
                return;
            }
            
            try {
                const data = JSON.parse(presetData);
                
                // Устанавливаем значения из пресета
                pixelSlider.value = data.pixelSlider;
                posterizeSlider.value = data.posterizeSlider;
                crtCheckbox.checked = data.crtCheckbox;
                shiftCheckbox.checked = data.shiftCheckbox;
                noiseSlider.value = data.noiseSlider;
                filmGrainSlider.value = data.filmGrainSlider;
                rowShiftSlider.value = data.rowShiftSlider;
                chromaticAberrationSlider.value = data.chromaticAberrationSlider;
                badPixelsSlider.value = data.badPixelsSlider;
                edgeDetectionSlider.value = data.edgeDetectionSlider;
                paletteSelect.value = data.paletteSelect;
                ditheringSelect.value = data.ditheringSelect;
                ditherStrengthSlider.value = data.ditherStrengthSlider;
                monoTintCheckbox.checked = data.monoTintCheckbox;
                tintColorSelect.value = data.tintColorSelect;
                screenGridCheckbox.checked = data.screenGridCheckbox;
                screenGridSizeSlider.value = data.screenGridSizeSlider;
                screenGridOpacitySlider.value = data.screenGridOpacitySlider;
                slightBlurSlider.value = data.slightBlurSlider;
                ntscArtifactsCheckbox.checked = data.ntscArtifactsCheckbox;
                ntscIntensitySlider.value = data.ntscIntensitySlider;
                barrelDistortionSlider.value = data.barrelDistortionSlider;
                
                updateCanvas();
                alert(`Пресет ${presetNum} загружен!`);
            } catch (e) {
                alert(`Ошибка загрузки пресета ${presetNum}: ${e.message}`);
            }
        }

        imgLoader.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                fileNameDisplay.textContent = file.name;
            } else {
                fileNameDisplay.textContent = 'Файл не выбран';
                originalImage = null;
                updateCanvas(); return;
            }
            const reader = new FileReader();
            reader.onload = function (event) {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    resetSettings(); updateCanvas();
                };
                img.onerror = () => {
                    console.error("Ошибка загрузки изображения.");
                    fileNameDisplay.textContent = 'Ошибка загрузки';
                    originalImage = null; updateCanvas();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        [
            pixelSlider, posterizeSlider, crtCheckbox, shiftCheckbox, noiseSlider,
            filmGrainSlider, rowShiftSlider, chromaticAberrationSlider, badPixelsSlider, edgeDetectionSlider,
            paletteSelect, ditheringSelect, ditherStrengthSlider, monoTintCheckbox, tintColorSelect,
            screenGridCheckbox, screenGridSizeSlider, screenGridOpacitySlider,
            slightBlurSlider, ntscArtifactsCheckbox, ntscIntensitySlider, barrelDistortionSlider
        ].forEach(control =>
            control.addEventListener('input', () => {
                requestAnimationFrame(updateCanvas);
            })
        );

        function resetSettings() {
            for (const key in defaultSettings) {
                const element = document.getElementById(key);
                if (element) {
                    if (element.type === 'checkbox') element.checked = defaultSettings[key];
                    else element.value = defaultSettings[key];
                }
            }
            requestAnimationFrame(updateCanvas);
        }

        // Helper: Get pixel from (x,y) in imageData
        function getPixel(imgData, x, y, width) {
            x = Math.max(0, Math.min(x, width - 1));
            y = Math.max(0, Math.min(y, imgData.height - 1));
            const i = (y * width + x) * 4;
            return [imgData.data[i], imgData.data[i+1], imgData.data[i+2], imgData.data[i+3]];
        }
        
        // Helper: Set pixel in imageData
        function setPixel(imgData, x, y, width, r, g, b, a) {
            const i = (y * width + x) * 4;
            imgData.data[i] = r;
            imgData.data[i+1] = g;
            imgData.data[i+2] = b;
            imgData.data[i+3] = a !== undefined ? a : 255;
        }
        
        // Helper: Color distance
        function colorDistanceSq(r1, g1, b1, r2, g2, b2) {
            return (r1 - r2)**2 + (g1 - g2)**2 + (b1 - b2)**2;
        }
        
        // Helper: Find closest color in palette
        function findClosestPaletteColor(r, g, b, currentPalette) {
            let closestColor = currentPalette[0];
            let minDistanceSq = colorDistanceSq(r, g, b, closestColor[0], closestColor[1], closestColor[2]);
            for (let i = 1; i < currentPalette.length; i++) {
                const distSq = colorDistanceSq(r, g, b, currentPalette[i][0], currentPalette[i][1], currentPalette[i][2]);
                if (distSq < minDistanceSq) {
                    minDistanceSq = distSq;
                    closestColor = currentPalette[i];
                }
            }
            return closestColor;
        }
        
        // Helper: Hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function updateCanvas() {
            if (!originalImage) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (canvas.width === 0 || canvas.height === 0) { canvas.width = 300; canvas.height = 150; }
                ctx.fillStyle = "#ddd"; ctx.fillRect(0,0,canvas.width, canvas.height);
                ctx.fillStyle = "#777"; ctx.textAlign = "center"; ctx.font = "16px Inter";
                ctx.fillText("Загрузите изображение", canvas.width/2, canvas.height/2);
                return;
            }

            const W_orig = originalImage.width;
            const H_orig = originalImage.height;
            
            const MAX_BUFFER_WIDTH = 800; const MAX_BUFFER_HEIGHT = 600;
            let bufferWidth = W_orig; let bufferHeight = H_orig;
            const aspectRatio = W_orig / H_orig;

            if (bufferWidth > MAX_BUFFER_WIDTH || bufferHeight > MAX_BUFFER_HEIGHT) {
                if ((bufferWidth / MAX_BUFFER_WIDTH) > (bufferHeight / MAX_BUFFER_HEIGHT)) {
                    bufferWidth = MAX_BUFFER_WIDTH; bufferHeight = bufferWidth / aspectRatio;
                } else {
                    bufferHeight = MAX_BUFFER_HEIGHT; bufferWidth = bufferHeight * aspectRatio;
                }
            }
            canvas.width = Math.max(1, Math.round(bufferWidth));
            canvas.height = Math.max(1, Math.round(bufferHeight));
            
            const CW = canvas.width;
            const CH = canvas.height;

            // --- 0. Pixelation (via temporary canvas) ---
            ctx.imageSmoothingEnabled = false; 
            const pixelFactor = +pixelSlider.value;
            const pixelationDownscale = Math.max(1, 100 / pixelFactor);
            
            const tmpCanvas = document.createElement('canvas');
            const tmpCtx = tmpCanvas.getContext('2d', { willReadFrequently: true }); 
            tmpCtx.imageSmoothingEnabled = (pixelationDownscale === 1);
            
            tmpCanvas.width = Math.max(1, Math.round(CW / pixelationDownscale));
            tmpCanvas.height = Math.max(1, Math.round(CH / pixelationDownscale));
            
            tmpCtx.drawImage(originalImage, 0, 0, W_orig, H_orig, 0, 0, tmpCanvas.width, tmpCanvas.height);
            ctx.drawImage(tmpCanvas, 0, 0, tmpCanvas.width, tmpCanvas.height, 0, 0, CW, CH);
            
            let imageData = ctx.getImageData(0, 0, CW, CH);
            let data = imageData.data;

            // --- Barrel Distortion ---
            const barrelStrength = +barrelDistortionSlider.value / 1000;
            if (barrelStrength > 0) {
                const k1 = barrelStrength * 10;
                const copyData = new Uint8ClampedArray(data);
                for (let y = 0; y < CH; y++) {
                    for (let x = 0; x < CW; x++) {
                        const normX = (2 * x / CW) - 1;
                        const normY = (2 * y / CH) - 1;
                        const rSq = normX * normX + normY * normY;
                        let srcX, srcY;
                        if (rSq < 1) {
                            const distortion = 1 + k1 * rSq;
                            const srcNormX = normX / distortion;
                            const srcNormY = normY / distortion;
                            srcX = Math.round((srcNormX + 1) * CW / 2);
                            srcY = Math.round((srcNormY + 1) * CH / 2);
                        } else {
                            srcX = x; srcY = y;
                        }
                        
                        if (srcX >= 0 && srcX < CW && srcY >= 0 && srcY < CH) {
                            const srcIdx = (srcY * CW + srcX) * 4;
                            const destIdx = (y * CW + x) * 4;
                            data[destIdx] = copyData[srcIdx];
                            data[destIdx + 1] = copyData[srcIdx + 1];
                            data[destIdx + 2] = copyData[srcIdx + 2];
                            data[destIdx + 3] = copyData[srcIdx + 3];
                        } else {
                             const destIdx = (y * CW + x) * 4;
                             data[destIdx] = data[destIdx+1] = data[destIdx+2] = 0; data[destIdx+3] = 255;
                        }
                    }
                }
            }

            // --- Palette Reduction & Dithering ---
            const selectedPaletteKey = paletteSelect.value;
            const selectedDithering = ditheringSelect.value;
            const ditherStrength = +ditherStrengthSlider.value / 255;

            if (selectedPaletteKey !== 'none') {
                const currentPalette = palettes[selectedPaletteKey];
                let bayerMatrix, bayerSize;
                if (selectedDithering.startsWith('bayer')) {
                    bayerMatrix = bayerMatrices[selectedDithering];
                    bayerSize = bayerMatrix.length;
                }

                for (let i = 0; i < data.length; i += 4) {
                    let r = data[i], g = data[i+1], b = data[i+2];

                    if (bayerMatrix) {
                        const x = (i / 4) % CW;
                        const y = Math.floor((i / 4) / CW);
                        const bayerVal = bayerMatrix[y % bayerSize][x % bayerSize];
                        const ditherOffset = (bayerVal / (bayerSize * bayerSize) - 0.5) * 255 * ditherStrength;
                        r = Math.min(255, Math.max(0, r + ditherOffset));
                        g = Math.min(255, Math.max(0, g + ditherOffset));
                        b = Math.min(255, Math.max(0, b + ditherOffset));
                    }
                    
                    const closest = findClosestPaletteColor(r, g, b, currentPalette);
                    data[i] = closest[0];
                    data[i+1] = closest[1];
                    data[i+2] = closest[2];
                }
            }
            
            // --- Monochrome / Tint ---
            if (monoTintCheckbox.checked) {
                const tintRgb = hexToRgb(tintColorSelect.value);
                if (tintRgb) {
                    for (let i = 0; i < data.length; i += 4) {
                        const luma = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
                        data[i]   = Math.min(255, luma * (tintRgb.r / 255) * 2);
                        data[i+1] = Math.min(255, luma * (tintRgb.g / 255) * 2);
                        data[i+2] = Math.min(255, luma * (tintRgb.b / 255) * 2);
                    }
                }
            }

            // --- Posterize ---
            const posterizeLevel = +posterizeSlider.value;
            if (posterizeLevel < defaultSettings.posterizeSlider && selectedPaletteKey === 'none') {
                const binSize = 255 / Math.max(1, posterizeLevel);
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.floor(data[i] / binSize) * binSize;
                    data[i+1] = Math.floor(data[i+1] / binSize) * binSize;
                    data[i+2] = Math.floor(data[i+2] / binSize) * binSize;
                }
            }

            // --- CRT Lines ---
            if (crtCheckbox.checked) {
                for (let y = 0; y < CH; y += 2) {
                    for (let x = 0; x < CW; x++) {
                        const i = (y * CW + x) * 4;
                        data[i] *= 0.7; data[i+1] *= 0.7; data[i+2] *= 0.7;
                    }
                }
            }
            
            // --- Color Shift (Old) ---
            if (shiftCheckbox.checked) {
                const offset = 2; 
                const prevDataShift = new Uint8ClampedArray(data);
                for (let y = 0; y < CH; y++) {
                    for (let x = 0; x < CW; x++) {
                        const i = (y * CW + x) * 4;
                        const redSrcX = Math.min(CW - 1, x + offset);
                        const redSrcIdx = (y * CW + redSrcX) * 4;
                        data[i] = prevDataShift[redSrcIdx];
                        data[i+2] = prevDataShift[i+2];
                    }
                }
            }

            // --- Chromatic Aberration ---
            const caAmount = +chromaticAberrationSlider.value;
            if (caAmount > 0) {
                const prevDataCA = new Uint8ClampedArray(data);
                for (let i = 0; i < data.length; i += 4) {
                    const x = (i / 4) % CW;
                    const y = Math.floor((i / 4) / CW);
                    const rIndex = (y * CW + Math.min(CW - 1, x + caAmount)) * 4;
                    const bIndex = (y * CW + Math.max(0, x - caAmount)) * 4;
                    data[i] = prevDataCA[rIndex];
                    data[i+1] = prevDataCA[i + 1];
                    data[i+2] = prevDataCA[bIndex + 2];
                }
            }
            
            // --- Row Shift (Scanline Displacement) ---
            const rowShiftMax = +rowShiftSlider.value;
            if (rowShiftMax > 0) {
                const prevDataRowShift = new Uint8ClampedArray(data);
                const tempRow = new Uint8ClampedArray(CW * 4);
                for (let y = 0; y < CH; y++) {
                    const shift = Math.floor((Math.random() - 0.5) * 2 * rowShiftMax);
                    if (shift === 0) continue;
                    const rowIndex = y * CW * 4;
                    for (let x = 0; x < CW; x++) {
                        const srcIdx = rowIndex + x * 4;
                        tempRow[x*4]=prevDataRowShift[srcIdx]; tempRow[x*4+1]=prevDataRowShift[srcIdx+1];
                        tempRow[x*4+2]=prevDataRowShift[srcIdx+2]; tempRow[x*4+3]=prevDataRowShift[srcIdx+3];
                    }
                    for (let x = 0; x < CW; x++) {
                        const targetX = (x - shift + CW) % CW;
                        const targetIdx = rowIndex + x * 4;
                        const srcIdxTemp = targetX * 4;
                        data[targetIdx] = tempRow[srcIdxTemp]; data[targetIdx+1] = tempRow[srcIdxTemp+1];
                        data[targetIdx+2] = tempRow[srcIdxTemp+2]; data[targetIdx+3] = tempRow[srcIdxTemp+3];
                    }
                }
            }

            // --- Simple Edge Detection ---
            const edgeThreshold = +edgeDetectionSlider.value;
            if (edgeThreshold > 0) {
                const prevDataEdge = new Uint8ClampedArray(data);
                const edgeOutput = new Uint8ClampedArray(data.length);
                for (let y = 1; y < CH - 1; y++) {
                    for (let x = 1; x < CW - 1; x++) {
                        const i = (y * CW + x) * 4;
                        const luma = (px) => 0.299*px[0] + 0.587*px[1] + 0.114*px[2];
                        
                        const currentLuma = luma([prevDataEdge[i], prevDataEdge[i+1], prevDataEdge[i+2]]);
                        const rightLuma = luma([prevDataEdge[i+4], prevDataEdge[i+5], prevDataEdge[i+6]]);
                        const bottomIdx = ((y+1)*CW + x)*4;
                        const bottomLuma = luma([prevDataEdge[bottomIdx], prevDataEdge[bottomIdx+1], prevDataEdge[bottomIdx+2]]);

                        const diff = Math.abs(currentLuma - rightLuma) + Math.abs(currentLuma - bottomLuma);
                        if (diff > edgeThreshold) {
                            edgeOutput[i] = edgeOutput[i+1] = edgeOutput[i+2] = 255; edgeOutput[i+3] = 255;
                        } else {
                            edgeOutput[i] = edgeOutput[i+1] = edgeOutput[i+2] = 0; edgeOutput[i+3] = 255;
                        }
                    }
                }
                 for(let i=0; i < data.length; i++) data[i] = edgeOutput[i];
            }
            
            // --- NTSC Artifacts (Simplified horizontal color bleed/shift) ---
            const ntscIntensity = +ntscIntensitySlider.value;
            if (ntscArtifactsCheckbox.checked && ntscIntensity > 0) {
                const prevDataNtsc = new Uint8ClampedArray(data);
                const shiftR = Math.floor(ntscIntensity / 4);
                const shiftB = -Math.floor(ntscIntensity / 4);
                for (let y = 0; y < CH; y++) {
                    for (let x = 0; x < CW; x++) {
                        const i = (y * CW + x) * 4;
                        const rSrcX = Math.max(0, Math.min(CW - 1, x + (y % 2 === 0 ? shiftR : -shiftR)));
                        const bSrcX = Math.max(0, Math.min(CW - 1, x + (y % 2 === 0 ? shiftB : -shiftB)));
                        
                        const rSrcIdx = (y * CW + rSrcX) * 4;
                        const bSrcIdx = (y * CW + bSrcX) * 4;

                        data[i] = prevDataNtsc[rSrcIdx];
                        data[i+1] = prevDataNtsc[i+1];
                        data[i+2] = prevDataNtsc[bSrcIdx+2];
                    }
                }
            }

            // --- Slight Blur (Box Blur) ---
            const blurRadius = +slightBlurSlider.value;
            if (blurRadius > 0) {
                const prevDataBlur = new Uint8ClampedArray(data);
                if (blurRadius === 1) {
                     for (let y = 0; y < CH; y++) {
                        for (let x = 0; x < CW; x++) {
                            let rSum = 0, gSum = 0, bSum = 0, count = 0;
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const curX = x + dx;
                                    const curY = y + dy;
                                    if (curX >= 0 && curX < CW && curY >= 0 && curY < CH) {
                                        const sIdx = (curY * CW + curX) * 4;
                                        rSum += prevDataBlur[sIdx];
                                        gSum += prevDataBlur[sIdx+1];
                                        bSum += prevDataBlur[sIdx+2];
                                        count++;
                                    }
                                }
                            }
                            const dIdx = (y * CW + x) * 4;
                            data[dIdx]   = rSum / count;
                            data[dIdx+1] = gSum / count;
                            data[dIdx+2] = bSum / count;
                        }
                    }
                }
            }

            // --- Screen Grid ---
            if (screenGridCheckbox.checked) {
                const gridSize = +screenGridSizeSlider.value;
                const gridOpacity = +screenGridOpacitySlider.value / 100;
                for (let y = 0; y < CH; y++) {
                    for (let x = 0; x < CW; x++) {
                        if (x % gridSize === 0 || y % gridSize === 0) {
                            const i = (y * CW + x) * 4;
                            data[i]   = data[i]   * (1 - gridOpacity);
                            data[i+1] = data[i+1] * (1 - gridOpacity);
                            data[i+2] = data[i+2] * (1 - gridOpacity);
                        }
                    }
                }
            }
            
            // --- Noise ---
            const noiseLevel = +noiseSlider.value;
            if (noiseLevel > 0) {
                const noiseAmount = noiseLevel * 2.55; 
                for (let i = 0; i < data.length; i += 4) {
                    const noise = (Math.random() - 0.5) * noiseAmount;
                    data[i] = Math.min(255,Math.max(0,data[i]+noise)); data[i+1]=Math.min(255,Math.max(0,data[i+1]+noise)); data[i+2]=Math.min(255,Math.max(0,data[i+2]+noise));
                }
            }

            // --- Film Grain ---
            const filmGrainAmount = +filmGrainSlider.value;
            if (filmGrainAmount > 0) {
                for (let i = 0; i < data.length; i += 4) {
                    const grain = (Math.random() - 0.5) * filmGrainAmount;
                    data[i] = Math.min(255,Math.max(0,data[i]+grain)); data[i+1]=Math.min(255,Math.max(0,data[i+1]+grain)); data[i+2]=Math.min(255,Math.max(0,data[i+2]+grain));
                }
            }

            // --- Bad Pixels ---
            const badPixelsPercent = +badPixelsSlider.value / 1000;
            if (badPixelsPercent > 0) {
                const numBadPixels = Math.floor(CW * CH * badPixelsPercent);
                for (let k = 0; k < numBadPixels; k++) {
                    const px = Math.floor(Math.random()*CW); const py = Math.floor(Math.random()*CH);
                    const i = (py * CW + px) * 4;
                    if (Math.random() < 0.7) { data[i]=data[i+1]=data[i+2]=0; } 
                    else { data[i]=Math.random()>0.5?255:Math.random()*100; data[i+1]=Math.random()>0.5?255:Math.random()*100; data[i+2]=Math.random()>0.5?255:Math.random()*100;}
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function saveImage() {
            if (!originalImage) { alert("Сначала загрузите изображение."); return; }
            const link = document.createElement('a');
            link.download = 'retro-edited-image.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        resetSettings();
        updateCanvas();
    </script>
</body>
</html>
