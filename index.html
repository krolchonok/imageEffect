<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Интерактивные эффекты</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        html {
            height: 100%;
        }
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            
            height: 100%;
            background: #f8f9fa;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center; /* Центрирует main-container если он имеет max-width */
        }

        header {
            background: #ffffff;
            width: 100%;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            flex-shrink: 0; /* Предотвращает сжатие хедера */
        }

        h1 {
            margin: 0;
            font-size: 24px;
        }

        .main-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 30px;
            max-width: 1200px;
            width: 100%;
            /* height: 90%; -- Удалено, flex-grow будет управлять высотой */
            flex-grow: 1; /* Занимает доступное пространство */
            overflow-y: auto; /* Позволяет скроллить содержимое, если оно больше */
        }

        .image-container {
            flex: 1;
            min-width: 300px;
            background: #fff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
        }

        .controls-container {
            flex: 1;
            min-width: 400px;
            background: #fff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            height: 100%; /* Сохраняем для desktop flex layout, чтобы .controls мог расти */
            max-height: calc(100vh - 100px); /* Ограничение высоты для desktop, чтобы помещался на экран */
        }


        .file-input-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .btn-file-upload {}

        .file-name-display {
            font-size: 14px;
            color: #555;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: calc(100% - 150px); /* Рассчитывается от ширины родителя */
        }

        canvas {
            display: block;
            max-width: 100%;
            /* max-height: 500px; -- Заменено на flex для image-container */
            width: auto;
            height: auto;
            margin-left: auto;
            margin-right: auto;
            border-radius: 8px;
            margin-bottom: 20px;
            background: #eee;
            object-fit: contain; /* Для сохранения пропорций, если задана высота */
            flex-grow: 1; /* Позволяет canvas занимать доступное место в image-container */
            min-height: 150px; /* Минимальная высота для пустого canvas */
        }


        .controls {
            flex-grow: 1; /* Позволяет блоку растягиваться */
            overflow-y: auto;
            padding-right: 10px; /* Для полосы прокрутки */
            border: 1px solid #eee;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            min-height: 300px; /* Минимальная высота */
        }

        .controls label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
            font-size: 13px;
        }

        .controls input[type="range"],
        .controls select {
            width: 50%;
        }
        
        .controls input[type="color"] {
            width: 50%;
            height: 25px;
        }

        .controls input[type="checkbox"] {
            transform: scale(1.1);
        }

        .button-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-top: 10px; /* Отодвигает от .controls */
            flex-shrink: 0;
        }

        .btn {
            background-color: #4f46e5;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            flex-grow: 1;
            text-align: center;
        }

        .btn-secondary {
            background-color: #6c757d;
        }

        .btn-secondary:hover {
            background-color: #5a6268;
        }

        .btn:hover {
            background-color: #3730a3;
        }

        .presets-container {
            margin-top: auto; /* Прижимаем к низу controls-container */
            border: 1px solid #eee;
            padding: 15px;
            border-radius: 8px;
            flex-shrink: 0; /* Запрещаем уменьшение */
        }

        .presets-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .presets-row:first-of-type {
            margin-top: 0; /* Убираем верхний отступ у первого ряда кнопок */
        }
        .presets-container h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .preset-btn {
            flex: 1;
        }

        /* --- Стили для мобильных устройств --- */
        @media (max-width: 768px) {
            body {
                height: auto; /* Позволяем body расти по контенту */
                align-items: stretch; /* Растягиваем .main-container на всю ширину */
            }
            
            h1 {
                font-size: 20px;
            }

            .main-container {
                flex-direction: column;
                align-items: stretch; /* Растягиваем дочерние элементы */
                margin: 15px;
                gap: 15px;
                flex-grow: 0; /* Убираем растягивание, высота по контенту */
                height: auto;
                overflow-y: visible; /* Скролл на уровне body */
                max-width: 100%; /* Убираем ограничение по ширине для мобильных */
            }

            .image-container,
            .controls-container {
                min-width: 100%;
                width: 100%;
                flex: none; /* Убираем flex-grow/shrink поведение от родителя */
                max-height: none; /* Сбрасываем max-height для controls-container */
            }
            
            .controls-container {
                height: auto; /* Высота по контенту */
            }

            .file-input-container {
                flex-direction: column;
                align-items: stretch; /* Растягиваем кнопку выбора файла */
                gap: 10px;
            }
            .btn-file-upload {
                width: 100%;
                text-align: center;
            }
            .file-name-display {
                max-width: 100%;
                text-align: center;
                margin-top: 5px;
            }

            canvas {
                max-height: 60vh; /* Ограничиваем высоту холста на мобильных */
                margin-bottom: 15px;
                flex-grow: 0; /* Canvas не должен сильно растягиваться, если изображение маленькое */
                aspect-ratio: attr(width) / attr(height); /* Попытка сохранить пропорции, если JS установит атрибуты */
            }
            .image-container canvas { /* Более специфичный селектор для canvas в image-container */
                 min-height: 200px; /* Убедимся, что у canvas есть минимальная высота */
            }


            .controls {
                padding-right: 5px;
                min-height: 200px; /* Можно уменьшить мин. высоту для мобильных */
            }

            .controls label {
                flex-direction: column; /* Текст над инпутом */
                align-items: flex-start; /* Выравнивание по левому краю */
                gap: 6px;
                font-size: 14px;
            }

            .controls input[type="range"],
            .controls select,
            .controls input[type="color"] {
                width: 100%; /* Инпуты на всю ширину */
            }

            .button-row {
                 /* flex-direction: column; -- Можно раскомментировать, если кнопки не помещаются */
                 /* gap: 8px; */
            }
            /* Если кнопки слишком широкие, можно сделать их в столбик */
            /* .button-row .btn {
                width: 100%;
            } */
            
            .presets-row {
                 /* flex-direction: column; -- Можно раскомментировать, если кнопки не помещаются */
                 /* gap: 8px; */
            }
             /* .presets-row .preset-btn {
                width: 100%;
            } */
        }

        @media (max-width: 480px) { /* Для очень маленьких экранов */
            header h1 {
                font-size: 18px;
            }
            .main-container {
                margin: 10px;
                gap: 10px;
            }
            .controls label {
                font-size: 13px;
            }
            .btn, .btn-secondary {
                padding: 10px 12px; /* Немного больше вертикального padding */
                font-size: 13px;
            }
            .button-row, .presets-row { /* Кнопки в столбик */
                flex-direction: column;
                gap: 8px;
            }
            .button-row .btn, .presets-row .btn { 
                width: 100%; /* Кнопки на всю ширину в столбике */
            }
            .presets-container h3 {
                font-size: 16px;
                text-align: center;
            }
        }
    </style>
</head>

<body>
    <header>
        <h1>Интерактивные эффекты для изображений</h1>
    </header>

    <div class="main-container">
        <div class="image-container">
            <div class="file-input-container">
                <input type="file" accept="image/*" id="imgLoader" class="visually-hidden">
                <label for="imgLoader" class="btn btn-file-upload">Выбрать файл</label>
                <span id="fileNameDisplay" class="file-name-display">Файл не выбран</span>
            </div>

            <canvas id="canvas"></canvas>
        </div>

        <div class="controls-container">
            <div class="controls">
                <label>Pixelation: <input type="range" id="pixelSlider" min="1" max="100" value="100"></label>
                <label>Posterize: <input type="range" id="posterizeSlider" min="1" max="50" value="50"></label>
                <label>CRT Lines: <input type="checkbox" id="crtCheckbox"></label>
                <label>Color Shift (Old): <input type="checkbox" id="shiftCheckbox"></label>
                <label>Noise: <input type="range" id="noiseSlider" min="0" max="100" value="0"></label>
                <label>Film Grain: <input type="range" id="filmGrainSlider" min="0" max="50" value="0"></label>
                <label>Row Shift: <input type="range" id="rowShiftSlider" min="0" max="30" value="0"></label>
                <label>Chromatic Aberration: <input type="range" id="chromaticAberrationSlider" min="0" max="10" value="0"></label>
                <label>Bad Pixels: <input type="range" id="badPixelsSlider" min="0" max="5" value="0"></label>
                <label>Simple Edges: <input type="range" id="edgeDetectionSlider" min="0" max="100" value="0"></label>
                
                <hr>

                <label>Palette:
                    <select id="paletteSelect">
                        <option value="none">None</option>
                        <option value="gameboy">Game Boy (4 Grays)</option>
                        <option value="nes8">NES-like (8 Colors)</option>
                        <option value="pico8">PICO-8 (16 Colors)</option>
                        <option value="websafe">Web Safe (216 Colors)</option>
                    </select>
                </label>
                <label>Dithering:
                    <select id="ditheringSelect">
                        <option value="none">None</option>
                        <option value="bayer2">Bayer 2x2</option>
                        <option value="bayer4">Bayer 4x4</option>
                    </select>
                </label>
                <label>Dither Strength: <input type="range" id="ditherStrengthSlider" min="0" max="100" value="20"></label>

                <label>Monochrome/Tint: <input type="checkbox" id="monoTintCheckbox"></label>
                <label>Tint Color:
                    <select id="tintColorSelect">
                        <option value="#9bbc0f">Game Boy Green</option>
                        <option value="#FF0000">Virtual Boy Red</option>
                        <option value="#FFB000">Amber</option>
                        <option value="#30FF30">Green CRT</option>
                        <option value="#808080">Grayscale</option>
                    </select>
                </label>

                <label>Screen Grid: <input type="checkbox" id="screenGridCheckbox"></label>
                <label>Grid Size: <input type="range" id="screenGridSizeSlider" min="1" max="10" value="3"></label>
                <label>Grid Opacity: <input type="range" id="screenGridOpacitySlider" min="0" max="100" value="30"></label>

                <label>Slight Blur: <input type="range" id="slightBlurSlider" min="0" max="5" value="0"></label>
                
                <label>NTSC Artifacts: <input type="checkbox" id="ntscArtifactsCheckbox"></label>
                <label>NTSC Intensity: <input type="range" id="ntscIntensitySlider" min="0" max="20" value="0"></label>

                <label>Barrel Distortion: <input type="range" id="barrelDistortionSlider" min="0" max="50" value="0"></label>
            </div>

            <div class="button-row">
                <button class="btn" onclick="updateCanvas()">Обновить</button>
                <button class="btn btn-secondary" onclick="resetSettings()">Сбросить</button>
                <button class="btn" onclick="saveImage()">Сохранить</button>
            </div>

            <div class="presets-container">
                <h3>Пресеты</h3>
                <div class="presets-row">
                    <button class="btn btn-secondary preset-btn" onclick="savePreset(1)">Сохранить 1</button>
                    <button class="btn btn-secondary preset-btn" onclick="loadPreset(1)">Загрузить 1</button>
                </div>
                <div class="presets-row">
                    <button class="btn btn-secondary preset-btn" onclick="savePreset(2)">Сохранить 2</button>
                    <button class="btn btn-secondary preset-btn" onclick="loadPreset(2)">Загрузить 2</button>
                </div>
                <div class="presets-row">
                    <button class="btn btn-secondary preset-btn" onclick="savePreset(3)">Сохранить 3</button>
                    <button class="btn btn-secondary preset-btn" onclick="loadPreset(3)">Загрузить 3</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const imgLoader = document.getElementById('imgLoader');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        let originalImage = null;

        // --- Ссылки на элементы управления ---
        const pixelSlider = document.getElementById('pixelSlider');
        const posterizeSlider = document.getElementById('posterizeSlider');
        const crtCheckbox = document.getElementById('crtCheckbox');
        const shiftCheckbox = document.getElementById('shiftCheckbox');
        const noiseSlider = document.getElementById('noiseSlider');
        const filmGrainSlider = document.getElementById('filmGrainSlider');
        const rowShiftSlider = document.getElementById('rowShiftSlider');
        const chromaticAberrationSlider = document.getElementById('chromaticAberrationSlider');
        const badPixelsSlider = document.getElementById('badPixelsSlider');
        const edgeDetectionSlider = document.getElementById('edgeDetectionSlider');
        const paletteSelect = document.getElementById('paletteSelect');
        const ditheringSelect = document.getElementById('ditheringSelect');
        const ditherStrengthSlider = document.getElementById('ditherStrengthSlider');
        const monoTintCheckbox = document.getElementById('monoTintCheckbox');
        const tintColorSelect = document.getElementById('tintColorSelect');
        const screenGridCheckbox = document.getElementById('screenGridCheckbox');
        const screenGridSizeSlider = document.getElementById('screenGridSizeSlider');
        const screenGridOpacitySlider = document.getElementById('screenGridOpacitySlider');
        const slightBlurSlider = document.getElementById('slightBlurSlider');
        const ntscArtifactsCheckbox = document.getElementById('ntscArtifactsCheckbox');
        const ntscIntensitySlider = document.getElementById('ntscIntensitySlider');
        const barrelDistortionSlider = document.getElementById('barrelDistortionSlider');

        // --- Начальные значения для сброса ---
        const defaultSettings = {
            pixelSlider: 100, posterizeSlider: 50, crtCheckbox: false, shiftCheckbox: false,
            noiseSlider: 0, filmGrainSlider: 0, rowShiftSlider: 0, chromaticAberrationSlider: 0,
            badPixelsSlider: 0, edgeDetectionSlider: 0,
            paletteSelect: 'none', ditheringSelect: 'none', ditherStrengthSlider: 20,
            monoTintCheckbox: false, tintColorSelect: '#9bbc0f',
            screenGridCheckbox: false, screenGridSizeSlider: 3, screenGridOpacitySlider: 30,
            slightBlurSlider: 0, ntscArtifactsCheckbox: false, ntscIntensitySlider: 0,
            barrelDistortionSlider: 0,
        };
        
        // --- Palettes ---
        const palettes = {
            gameboy: [[155, 188, 15], [139, 172, 15], [48, 98, 48], [15, 56, 15]],
            nes8: [[124,124,124],[0,0,252],[0,0,188],[68,40,188],[148,0,132],[188,0,0],[188,80,0],[160,120,0]],
            pico8: [[0,0,0],[29,43,83],[126,37,83],[0,135,81],[171,82,54],[95,87,79],[194,195,199],[255,241,232],[255,0,77],[255,163,0],[255,236,39],[0,228,54],[41,173,255],[131,118,156],[255,119,168],[255,204,170]],
            websafe: (() => {
                const p = []; const v = [0, 51, 102, 153, 204, 255];
                for (let r of v) for (let g of v) for (let b of v) p.push([r,g,b]);
                return p;
            })()
        };

        // --- Dithering Matrices ---
        const bayerMatrices = {
            bayer2: [[0, 2], [3, 1]],
            bayer4: [[0, 8, 2, 10], [12, 4, 14, 6], [3, 11, 1, 9], [15, 7, 13, 5]]
        };

        // --- Cookie Functions ---
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days*24*60*60*1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "")  + expires + "; path=/; SameSite=Lax"; // Added SameSite
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for(let i=0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0)==' ') c = c.substring(1,c.length);
                if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
            }
            return null;
        }

        function savePreset(presetNum) {
            const presetData = {
                pixelSlider: pixelSlider.value,
                posterizeSlider: posterizeSlider.value,
                crtCheckbox: crtCheckbox.checked,
                shiftCheckbox: shiftCheckbox.checked,
                noiseSlider: noiseSlider.value,
                filmGrainSlider: filmGrainSlider.value,
                rowShiftSlider: rowShiftSlider.value,
                chromaticAberrationSlider: chromaticAberrationSlider.value,
                badPixelsSlider: badPixelsSlider.value,
                edgeDetectionSlider: edgeDetectionSlider.value,
                paletteSelect: paletteSelect.value,
                ditheringSelect: ditheringSelect.value,
                ditherStrengthSlider: ditherStrengthSlider.value,
                monoTintCheckbox: monoTintCheckbox.checked,
                tintColorSelect: tintColorSelect.value,
                screenGridCheckbox: screenGridCheckbox.checked,
                screenGridSizeSlider: screenGridSizeSlider.value,
                screenGridOpacitySlider: screenGridOpacitySlider.value,
                slightBlurSlider: slightBlurSlider.value,
                ntscArtifactsCheckbox: ntscArtifactsCheckbox.checked,
                ntscIntensitySlider: ntscIntensitySlider.value,
                barrelDistortionSlider: barrelDistortionSlider.value
            };
            
            setCookie(`preset_${presetNum}`, JSON.stringify(presetData), 365);
            alert(`Пресет ${presetNum} сохранён!`);
        }

        function loadPreset(presetNum) {
            const presetData = getCookie(`preset_${presetNum}`);
            if (!presetData) {
                alert(`Пресет ${presetNum} не найден!`);
                return;
            }
            
            try {
                const data = JSON.parse(presetData);
                
                pixelSlider.value = data.pixelSlider;
                posterizeSlider.value = data.posterizeSlider;
                crtCheckbox.checked = data.crtCheckbox;
                shiftCheckbox.checked = data.shiftCheckbox;
                noiseSlider.value = data.noiseSlider;
                filmGrainSlider.value = data.filmGrainSlider;
                rowShiftSlider.value = data.rowShiftSlider;
                chromaticAberrationSlider.value = data.chromaticAberrationSlider;
                badPixelsSlider.value = data.badPixelsSlider;
                edgeDetectionSlider.value = data.edgeDetectionSlider;
                paletteSelect.value = data.paletteSelect;
                ditheringSelect.value = data.ditheringSelect;
                ditherStrengthSlider.value = data.ditherStrengthSlider;
                monoTintCheckbox.checked = data.monoTintCheckbox;
                tintColorSelect.value = data.tintColorSelect;
                screenGridCheckbox.checked = data.screenGridCheckbox;
                screenGridSizeSlider.value = data.screenGridSizeSlider;
                screenGridOpacitySlider.value = data.screenGridOpacitySlider;
                slightBlurSlider.value = data.slightBlurSlider;
                ntscArtifactsCheckbox.checked = data.ntscArtifactsCheckbox;
                ntscIntensitySlider.value = data.ntscIntensitySlider;
                barrelDistortionSlider.value = data.barrelDistortionSlider;
                
                updateCanvas();
                alert(`Пресет ${presetNum} загружен!`);
            } catch (e) {
                alert(`Ошибка загрузки пресета ${presetNum}: ${e.message}`);
                console.error("Preset load error:", e);
            }
        }

        imgLoader.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                fileNameDisplay.textContent = file.name;
            } else {
                fileNameDisplay.textContent = 'Файл не выбран';
                originalImage = null;
                // Сброс canvas при удалении файла
                canvas.width = canvas.width; // Очистка
                canvas.removeAttribute("width"); // Удаляем атрибуты, чтобы CSS мог управлять размером
                canvas.removeAttribute("height");
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                updateCanvas(); return;
            }
            const reader = new FileReader();
            reader.onload = function (event) {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                     // Устанавливаем атрибуты для aspect-ratio CSS
                    canvas.setAttribute('width', img.width);
                    canvas.setAttribute('height', img.height);
                    resetSettings(); updateCanvas();
                };
                img.onerror = () => {
                    console.error("Ошибка загрузки изображения.");
                    fileNameDisplay.textContent = 'Ошибка загрузки';
                    originalImage = null; 
                    canvas.removeAttribute("width");
                    canvas.removeAttribute("height");
                    updateCanvas();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        [
            pixelSlider, posterizeSlider, crtCheckbox, shiftCheckbox, noiseSlider,
            filmGrainSlider, rowShiftSlider, chromaticAberrationSlider, badPixelsSlider, edgeDetectionSlider,
            paletteSelect, ditheringSelect, ditherStrengthSlider, monoTintCheckbox, tintColorSelect,
            screenGridCheckbox, screenGridSizeSlider, screenGridOpacitySlider,
            slightBlurSlider, ntscArtifactsCheckbox, ntscIntensitySlider, barrelDistortionSlider
        ].forEach(control =>
            control.addEventListener('input', () => {
                if (originalImage) { // Обновляем только если есть изображение
                    requestAnimationFrame(updateCanvas);
                }
            })
        );

        function resetSettings() {
            for (const key in defaultSettings) {
                const element = document.getElementById(key);
                if (element) {
                    if (element.type === 'checkbox') element.checked = defaultSettings[key];
                    else element.value = defaultSettings[key];
                }
            }
            if (originalImage) { // Обновляем только если есть изображение
                 requestAnimationFrame(updateCanvas);
            } else { // Если изображения нет, просто отображаем placeholder
                updateCanvas();
            }
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function colorDistanceSq(r1, g1, b1, r2, g2, b2) {
            return (r1 - r2)**2 + (g1 - g2)**2 + (b1 - b2)**2;
        }
        
        function findClosestPaletteColor(r, g, b, currentPalette) {
            let closestColor = currentPalette[0];
            let minDistanceSq = colorDistanceSq(r, g, b, closestColor[0], closestColor[1], closestColor[2]);
            for (let i = 1; i < currentPalette.length; i++) {
                const distSq = colorDistanceSq(r, g, b, currentPalette[i][0], currentPalette[i][1], currentPalette[i][2]);
                if (distSq < minDistanceSq) {
                    minDistanceSq = distSq;
                    closestColor = currentPalette[i];
                }
            }
            return closestColor;
        }

        function updateCanvas() {
            if (!originalImage) {
                // Используем CSS размеры canvas, если атрибуты не заданы
                const displayWidth = canvas.clientWidth || 300;
                const displayHeight = canvas.clientHeight || 150;
                
                // Устанавливаем внутренний размер canvas равным отображаемому, если он еще не установлен
                if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                    canvas.width = displayWidth;
                    canvas.height = displayHeight;
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#ddd"; 
                ctx.fillRect(0,0,canvas.width, canvas.height);
                ctx.fillStyle = "#777"; 
                ctx.textAlign = "center"; 
                ctx.font = "16px Inter";
                ctx.fillText("Загрузите изображение", canvas.width/2, canvas.height/2);
                return;
            }

            const W_orig = originalImage.width;
            const H_orig = originalImage.height;
            
            // Определяем максимальный размер буфера (для производительности)
            // Можно использовать размеры контейнера canvas как ориентир для макс. разрешения
            const canvasContainer = canvas.parentElement;
            const MAX_BUFFER_WIDTH = Math.min(1200, canvasContainer.clientWidth > 0 ? canvasContainer.clientWidth * 1.5 : W_orig); // x1.5 для запаса качества
            const MAX_BUFFER_HEIGHT = Math.min(1000, canvasContainer.clientHeight > 0 ? canvasContainer.clientHeight * 1.5 : H_orig);

            let bufferWidth = W_orig; 
            let bufferHeight = H_orig;
            const aspectRatio = W_orig / H_orig;

            if (bufferWidth > MAX_BUFFER_WIDTH || bufferHeight > MAX_BUFFER_HEIGHT) {
                if ((bufferWidth / MAX_BUFFER_WIDTH) > (bufferHeight / MAX_BUFFER_HEIGHT)) {
                    bufferWidth = MAX_BUFFER_WIDTH; 
                    bufferHeight = bufferWidth / aspectRatio;
                } else {
                    bufferHeight = MAX_BUFFER_HEIGHT; 
                    bufferWidth = bufferHeight * aspectRatio;
                }
            }
            // Устанавливаем атрибуты и внутренний размер canvas
            canvas.width = Math.max(1, Math.round(bufferWidth));
            canvas.height = Math.max(1, Math.round(bufferHeight));
            // Также устанавливаем атрибуты для CSS aspect-ratio
            canvas.setAttribute('width', canvas.width);
            canvas.setAttribute('height', canvas.height);
            
            const CW = canvas.width;
            const CH = canvas.height;

            ctx.imageSmoothingEnabled = false; 
            const pixelFactor = +pixelSlider.value;
            const pixelationDownscale = Math.max(1, 100 / pixelFactor);
            
            const tmpCanvas = document.createElement('canvas');
            const tmpCtx = tmpCanvas.getContext('2d', { willReadFrequently: true }); 
            tmpCtx.imageSmoothingEnabled = (pixelationDownscale <= 1.5); // Небольшое сглаживание при малом даунскейле
            
            tmpCanvas.width = Math.max(1, Math.round(CW / pixelationDownscale));
            tmpCanvas.height = Math.max(1, Math.round(CH / pixelationDownscale));
            
            tmpCtx.drawImage(originalImage, 0, 0, W_orig, H_orig, 0, 0, tmpCanvas.width, tmpCanvas.height);
            ctx.drawImage(tmpCanvas, 0, 0, tmpCanvas.width, tmpCanvas.height, 0, 0, CW, CH);
            
            let imageData = ctx.getImageData(0, 0, CW, CH);
            let data = imageData.data;

            const barrelStrength = +barrelDistortionSlider.value / 1000;
            if (barrelStrength > 0) {
                const k1 = barrelStrength * 10;
                const copyData = new Uint8ClampedArray(data);
                const centerX = CW / 2;
                const centerY = CH / 2;
                const maxRadiusSq = centerX * centerX + centerY * centerY;

                for (let y = 0; y < CH; y++) {
                    for (let x = 0; x < CW; x++) {
                        const normX = (x - centerX) / centerX;
                        const normY = (y - centerY) / centerY;
                        const rSqUnscaled = (x - centerX)*(x - centerX) + (y - centerY)*(y - centerY);
                        const rSq = rSqUnscaled / maxRadiusSq; // Normalize radius for consistent effect
                        
                        let srcX, srcY;
                        if (rSq < 1) { // Apply only within a circle to avoid extreme edge distortion
                            const distortion = 1 + k1 * rSq;
                            const srcNormX = normX / distortion;
                            const srcNormY = normY / distortion;
                            srcX = Math.round(srcNormX * centerX + centerX);
                            srcY = Math.round(srcNormY * centerY + centerY);
                        } else {
                            srcX = x; srcY = y;
                        }
                        
                        const destIdx = (y * CW + x) * 4;
                        if (srcX >= 0 && srcX < CW && srcY >= 0 && srcY < CH) {
                            const srcIdx = (srcY * CW + srcX) * 4;
                            data[destIdx] = copyData[srcIdx];
                            data[destIdx + 1] = copyData[srcIdx + 1];
                            data[destIdx + 2] = copyData[srcIdx + 2];
                            data[destIdx + 3] = copyData[srcIdx + 3];
                        } else {
                             data[destIdx] = data[destIdx+1] = data[destIdx+2] = 0; data[destIdx+3] = 255; // Fill with black if out of bounds
                        }
                    }
                }
            }

            const selectedPaletteKey = paletteSelect.value;
            const selectedDithering = ditheringSelect.value;
            const ditherStrength = +ditherStrengthSlider.value / 255;

            if (selectedPaletteKey !== 'none') {
                const currentPalette = palettes[selectedPaletteKey];
                let bayerMatrix, bayerSize;
                if (selectedDithering.startsWith('bayer') && bayerMatrices[selectedDithering]) {
                    bayerMatrix = bayerMatrices[selectedDithering];
                    bayerSize = bayerMatrix.length;
                }

                for (let i = 0; i < data.length; i += 4) {
                    let r = data[i], g = data[i+1], b = data[i+2];

                    if (bayerMatrix) {
                        const x = (i / 4) % CW;
                        const y = Math.floor((i / 4) / CW);
                        const bayerVal = bayerMatrix[y % bayerSize][x % bayerSize];
                        const ditherOffset = (bayerVal / (bayerSize * bayerSize) - 0.5) * 255 * ditherStrength;
                        r = Math.min(255, Math.max(0, r + ditherOffset));
                        g = Math.min(255, Math.max(0, g + ditherOffset));
                        b = Math.min(255, Math.max(0, b + ditherOffset));
                    }
                    
                    const closest = findClosestPaletteColor(r, g, b, currentPalette);
                    data[i] = closest[0]; data[i+1] = closest[1]; data[i+2] = closest[2];
                }
            }
            
            if (monoTintCheckbox.checked) {
                const tintRgb = hexToRgb(tintColorSelect.value);
                if (tintRgb) {
                    for (let i = 0; i < data.length; i += 4) {
                        const luma = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
                        data[i]   = Math.min(255, luma * (tintRgb.r / 255) * 2); // x2 factor can be adjusted for brightness
                        data[i+1] = Math.min(255, luma * (tintRgb.g / 255) * 2);
                        data[i+2] = Math.min(255, luma * (tintRgb.b / 255) * 2);
                    }
                }
            }

            const posterizeLevel = +posterizeSlider.value;
            if (posterizeLevel < defaultSettings.posterizeSlider && selectedPaletteKey === 'none') { // Apply only if no palette
                const numLevels = Math.max(1, posterizeLevel);
                const binSize = 256 / numLevels; // 256 to include 255 properly
                for (let i = 0; i < data.length; i += 4) {
                    data[i]   = Math.min(255, Math.floor(data[i] / binSize) * binSize + binSize/2); // Center of bin
                    data[i+1] = Math.min(255, Math.floor(data[i+1] / binSize) * binSize + binSize/2);
                    data[i+2] = Math.min(255, Math.floor(data[i+2] / binSize) * binSize + binSize/2);
                }
            }

            if (crtCheckbox.checked) {
                for (let y = 0; y < CH; y += 2) {
                    for (let x = 0; x < CW; x++) {
                        const i = (y * CW + x) * 4;
                        data[i] *= 0.7; data[i+1] *= 0.7; data[i+2] *= 0.7;
                    }
                }
            }
            
            if (shiftCheckbox.checked) {
                const offset = 2; 
                const prevDataShift = new Uint8ClampedArray(data);
                for (let y = 0; y < CH; y++) {
                    for (let x = 0; x < CW; x++) {
                        const i = (y * CW + x) * 4;
                        const redSrcX = Math.min(CW - 1, x + offset);
                        const redSrcIdx = (y * CW + redSrcX) * 4;
                        const blueSrcX = Math.max(0, x - offset);
                        const blueSrcIdx = (y * CW + blueSrcX) * 4;

                        data[i]   = prevDataShift[redSrcIdx];     // Red channel from shifted right
                        // data[i+1] keeps its green value
                        data[i+2] = prevDataShift[blueSrcIdx + 2]; // Blue channel from shifted left
                    }
                }
            }

            const caAmount = +chromaticAberrationSlider.value;
            if (caAmount > 0) {
                const prevDataCA = new Uint8ClampedArray(data);
                for (let i = 0; i < data.length; i += 4) {
                    const x = (i / 4) % CW;
                    const y = Math.floor((i / 4) / CW);
                    const rIndex = (y * CW + Math.min(CW - 1, x + caAmount)) * 4;
                    const bIndex = (y * CW + Math.max(0, x - caAmount)) * 4;
                    data[i] = prevDataCA[rIndex]; // Red
                    data[i+1] = prevDataCA[i + 1];   // Green
                    data[i+2] = prevDataCA[bIndex + 2]; // Blue
                }
            }
            
            const rowShiftMax = +rowShiftSlider.value;
            if (rowShiftMax > 0) {
                const prevDataRowShift = new Uint8ClampedArray(data);
                const tempRow = new Uint8ClampedArray(CW * 4);
                for (let y = 0; y < CH; y++) {
                    const shift = Math.floor((Math.random() - 0.5) * 2 * rowShiftMax);
                    if (shift === 0) continue;
                    
                    const rowIndex = y * CW * 4;
                    // Copy original row to tempRow
                    for (let x_col = 0; x_col < CW; x_col++) {
                        const srcIdx = rowIndex + x_col * 4;
                        tempRow[x_col*4]   = prevDataRowShift[srcIdx];
                        tempRow[x_col*4+1] = prevDataRowShift[srcIdx+1];
                        tempRow[x_col*4+2] = prevDataRowShift[srcIdx+2];
                        tempRow[x_col*4+3] = prevDataRowShift[srcIdx+3];
                    }
                    // Write shifted row from tempRow back to data
                    for (let x_col = 0; x_col < CW; x_col++) {
                        const targetXOriginal = (x_col - shift); // Where this pixel *came from* in original
                        let srcXShifted = (x_col - shift + CW*1000) % CW; // Ensure positive for modulo
                        
                        const targetIdx = rowIndex + x_col * 4;
                        const srcIdxTemp = srcXShifted * 4;

                        data[targetIdx]   = tempRow[srcIdxTemp];
                        data[targetIdx+1] = tempRow[srcIdxTemp+1];
                        data[targetIdx+2] = tempRow[srcIdxTemp+2];
                        data[targetIdx+3] = tempRow[srcIdxTemp+3];
                    }
                }
            }

            const edgeThreshold = +edgeDetectionSlider.value;
            if (edgeThreshold > 0) {
                const prevDataEdge = new Uint8ClampedArray(data);
                // For edge detection, usually better to output to a new buffer or make non-edge pixels transparent/original
                for (let y = 1; y < CH - 1; y++) {
                    for (let x = 1; x < CW - 1; x++) {
                        const i = (y * CW + x) * 4;
                        const luma = (r,g,b) => 0.299*r + 0.587*g + 0.114*b;
                        
                        const currentLuma = luma(prevDataEdge[i], prevDataEdge[i+1], prevDataEdge[i+2]);
                        
                        const gx = 
                            -luma(prevDataEdge[((y-1)*CW + (x-1))*4], prevDataEdge[((y-1)*CW + (x-1))*4+1], prevDataEdge[((y-1)*CW + (x-1))*4+2])
                            -2*luma(prevDataEdge[(y*CW + (x-1))*4], prevDataEdge[(y*CW + (x-1))*4+1], prevDataEdge[(y*CW + (x-1))*4+2])
                            -luma(prevDataEdge[((y+1)*CW + (x-1))*4], prevDataEdge[((y+1)*CW + (x-1))*4+1], prevDataEdge[((y+1)*CW + (x-1))*4+2])
                            +luma(prevDataEdge[((y-1)*CW + (x+1))*4], prevDataEdge[((y-1)*CW + (x+1))*4+1], prevDataEdge[((y-1)*CW + (x+1))*4+2])
                            +2*luma(prevDataEdge[(y*CW + (x+1))*4], prevDataEdge[(y*CW + (x+1))*4+1], prevDataEdge[(y*CW + (x+1))*4+2])
                            +luma(prevDataEdge[((y+1)*CW + (x+1))*4], prevDataEdge[((y+1)*CW + (x+1))*4+1], prevDataEdge[((y+1)*CW + (x+1))*4+2]);
                        
                        const gy =
                            -luma(prevDataEdge[((y-1)*CW + (x-1))*4], prevDataEdge[((y-1)*CW + (x-1))*4+1], prevDataEdge[((y-1)*CW + (x-1))*4+2])
                            -2*luma(prevDataEdge[((y-1)*CW + x)*4], prevDataEdge[((y-1)*CW + x)*4+1], prevDataEdge[((y-1)*CW + x)*4+2])
                            -luma(prevDataEdge[((y-1)*CW + (x+1))*4], prevDataEdge[((y-1)*CW + (x+1))*4+1], prevDataEdge[((y-1)*CW + (x+1))*4+2])
                            +luma(prevDataEdge[((y+1)*CW + (x-1))*4], prevDataEdge[((y+1)*CW + (x-1))*4+1], prevDataEdge[((y+1)*CW + (x-1))*4+2])
                            +2*luma(prevDataEdge[((y+1)*CW + x)*4], prevDataEdge[((y+1)*CW + x)*4+1], prevDataEdge[((y+1)*CW + x)*4+2])
                            +luma(prevDataEdge[((y+1)*CW + (x+1))*4], prevDataEdge[((y+1)*CW + (x+1))*4+1], prevDataEdge[((y+1)*CW + (x+1))*4+2]);

                        const magnitude = Math.sqrt(gx*gx + gy*gy);
                        if (magnitude > edgeThreshold) { // Edge threshold is now 0-255 essentially
                            data[i] = data[i+1] = data[i+2] = 255; // White edges
                        } else {
                            data[i] = data[i+1] = data[i+2] = 0;   // Black non-edges
                        }
                        // data[i+3] = 255; // Alpha
                    }
                }
            }
            
            const ntscIntensity = +ntscIntensitySlider.value;
            if (ntscArtifactsCheckbox.checked && ntscIntensity > 0) {
                const prevDataNtsc = new Uint8ClampedArray(data);
                // NTSC-like horizontal color bleed/shift (simplified)
                const phaseShift = Math.PI / 3; // Approx 60 degrees for YIQ-like components
                for (let y = 0; y < CH; y++) {
                    for (let x = 0; x < CW; x++) {
                        const i = (y * CW + x) * 4;
                        // Modulate based on horizontal position and intensity
                        const modulation = Math.sin(x * (ntscIntensity / 100) + y * 0.1); // y*0.1 adds slight diagonal crawl
                        
                        const rSrcX = Math.max(0, Math.min(CW - 1, x + Math.round(modulation * 2))); // Shift R
                        const bSrcX = Math.max(0, Math.min(CW - 1, x - Math.round(modulation * 1))); // Shift B oppositely

                        const rSrcIdx = (y * CW + rSrcX) * 4;
                        const bSrcIdx = (y * CW + bSrcX) * 4;

                        data[i]   = prevDataNtsc[rSrcIdx];     // Shifted Red
                        data[i+1] = prevDataNtsc[i+1];         // Green (less affected or reference)
                        data[i+2] = prevDataNtsc[bSrcIdx + 2]; // Shifted Blue
                    }
                }
            }

            const blurRadius = +slightBlurSlider.value;
            if (blurRadius > 0) { // Simple Box Blur
                const prevDataBlur = new Uint8ClampedArray(data);
                const kernelSize = blurRadius * 2 + 1;
                const halfKernel = blurRadius;

                for (let y = 0; y < CH; y++) {
                    for (let x = 0; x < CW; x++) {
                        let rSum = 0, gSum = 0, bSum = 0, count = 0;
                        for (let dy = -halfKernel; dy <= halfKernel; dy++) {
                            for (let dx = -halfKernel; dx <= halfKernel; dx++) {
                                const curX = x + dx;
                                const curY = y + dy;
                                if (curX >= 0 && curX < CW && curY >= 0 && curY < CH) {
                                    const sIdx = (curY * CW + curX) * 4;
                                    rSum += prevDataBlur[sIdx];
                                    gSum += prevDataBlur[sIdx+1];
                                    bSum += prevDataBlur[sIdx+2];
                                    count++;
                                }
                            }
                        }
                        const dIdx = (y * CW + x) * 4;
                        data[dIdx]   = rSum / count;
                        data[dIdx+1] = gSum / count;
                        data[dIdx+2] = bSum / count;
                    }
                }
            }


            if (screenGridCheckbox.checked) {
                const gridSize = +screenGridSizeSlider.value;
                const gridOpacity = +screenGridOpacitySlider.value / 100;
                for (let y = 0; y < CH; y++) {
                    for (let x = 0; x < CW; x++) {
                        if (x % gridSize === 0 || y % gridSize === 0) {
                            const i = (y * CW + x) * 4;
                            data[i]   = data[i]   * (1 - gridOpacity) + 0 * gridOpacity; // Blend with black
                            data[i+1] = data[i+1] * (1 - gridOpacity) + 0 * gridOpacity;
                            data[i+2] = data[i+2] * (1 - gridOpacity) + 0 * gridOpacity;
                        }
                    }
                }
            }
            
            const noiseLevel = +noiseSlider.value;
            if (noiseLevel > 0) {
                const noiseAmount = noiseLevel * 2.55; // Max noise of 255
                for (let i = 0; i < data.length; i += 4) {
                    const noise = (Math.random() - 0.5) * noiseAmount;
                    data[i] = Math.min(255,Math.max(0,data[i]+noise)); 
                    data[i+1]=Math.min(255,Math.max(0,data[i+1]+noise)); 
                    data[i+2]=Math.min(255,Math.max(0,data[i+2]+noise));
                }
            }

            const filmGrainAmount = +filmGrainSlider.value; // More subtle than noise
            if (filmGrainAmount > 0) {
                for (let i = 0; i < data.length; i += 4) {
                    const grain = (Math.random() - 0.5) * filmGrainAmount;
                    data[i] = Math.min(255,Math.max(0,data[i]+grain)); 
                    data[i+1]=Math.min(255,Math.max(0,data[i+1]+grain)); 
                    data[i+2]=Math.min(255,Math.max(0,data[i+2]+grain));
                }
            }

            const badPixelsPercent = +badPixelsSlider.value / 1000;
            if (badPixelsPercent > 0) {
                const numBadPixels = Math.floor(CW * CH * badPixelsPercent);
                for (let k = 0; k < numBadPixels; k++) {
                    const px = Math.floor(Math.random()*CW); 
                    const py = Math.floor(Math.random()*CH);
                    const i = (py * CW + px) * 4;
                    const type = Math.random();
                    if (type < 0.6) { data[i]=data[i+1]=data[i+2]=0; } // Dead pixel
                    else if (type < 0.9) { data[i]=255; data[i+1]=0; data[i+2]=0; } // Stuck red
                    else { data[i]=0; data[i+1]=255; data[i+2]=0; } // Stuck green etc.
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function saveImage() {
            if (!originalImage) { alert("Сначала загрузите изображение."); return; }
            const link = document.createElement('a');
            const fileNameBase = originalImage.name ? originalImage.name.split('.')[0] : 'image';
            link.download = `${fileNameBase}-retro-edited.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // Initial placeholder draw
        resetSettings(); // This will call updateCanvas which handles the no-image case
    </script>
</body>
</html>
